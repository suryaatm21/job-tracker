name: Cache cleanup

on:
  schedule:
    - cron: '0 8 * * *' # Daily cleanup: 08:00 UTC
  workflow_dispatch:
    inputs:
      dry_run:
        description: "List caches without deleting"
        required: false
        default: "true"
        type: choice
        options: ["true", "false"]
      keep_prefixes:
        description: "Comma-separated prefixes to keep"
        required: false
        default: "dm-watcher-state-v1,channel-digest-state-v1,channel-digest-testing-state-v1"
        type: string
      keep_n_per_prefix:
        description: "How many newest caches to keep per prefix"
        required: false
        default: "3"
        type: string

permissions:
  contents: read
  actions: write

jobs:
  cleanup:
    runs-on: ubuntu-latest
    env:
      DEFAULT_KEEP_PREFIXES: dm-watcher-state-v1,channel-digest-state-v1,channel-digest-testing-state-v1
      DEFAULT_KEEP_N: "3"
    steps:
      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

      - name: Show cache summary (before)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api repos/${{ github.repository }}/actions/caches --paginate --jq '.actions_caches[]' \
            | jq -r '"\(.id) | \(.key) | \(.size_in_bytes) bytes | created \(.created_at)"' \
            | awk 'NR<=100'

      - name: Delete old caches (keep N newest per prefix; delete others)
        if: ${{ github.event.inputs.dry_run != 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          KEEP_PREFIXES: ${{ github.event.inputs.keep_prefixes || env.DEFAULT_KEEP_PREFIXES }}
          KEEP_N: ${{ github.event.inputs.keep_n_per_prefix || env.DEFAULT_KEEP_N }}
        run: |
          # Build prefixes array, dropping empty entries
          IFS=',' read -r -a raw_prefixes <<< "$KEEP_PREFIXES"
          prefixes=()
          for p in "${raw_prefixes[@]}"; do
            p_trimmed="${p// /}"
            [[ -n "$p_trimmed" ]] && prefixes+=("$p_trimmed")
          done
          if [[ ${#prefixes[@]} -eq 0 ]]; then
            echo "No valid KEEP_PREFIXES provided; skipping deletion to avoid unintended pruning."
            exit 0
          fi
          # Delete caches not matching any prefix
          gh api repos/${{ github.repository }}/actions/caches --paginate --jq '.actions_caches[]' \
            | jq -r '[.id, .key] | @tsv' \
            | while IFS=$'\t' read -r id key; do
                match=0
                for p in "${prefixes[@]}"; do
                  [[ "$key" == "$p"* ]] && match=1 && break
                done
                if [[ $match -eq 0 ]]; then
                  echo "Deleting non-matching cache id=$id key=$key"
                  gh api -X DELETE repos/${{ github.repository }}/actions/caches/$id || true
                fi
              done

          # For each prefix, keep only the newest N and delete older ones
          for p in "${prefixes[@]}"; do
            echo "Processing prefix: $p (keeping $KEEP_N)"
            gh api repos/${{ github.repository }}/actions/caches --paginate --jq '.actions_caches[]' \
              | jq --arg prefix "$p" -r 'select(.key | startswith($prefix)) | [.id, .key, .created_at] | @tsv' \
              | sort -k3 -r \
              | awk -v keep="$KEEP_N" 'NR>keep {print $0}' \
              | cut -f1 \
              | while read -r id; do
              	  [[ -z "$id" ]] && continue
                  echo "Deleting older cache id=$id (prefix=$p)"
                  gh api -X DELETE repos/${{ github.repository }}/actions/caches/$id || true
                done
          done

      - name: Show cache summary (after)
        if: ${{ github.event.inputs.dry_run != 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh api repos/${{ github.repository }}/actions/caches --paginate --jq '.actions_caches[]' \
            | jq -r '"\(.id) | \(.key) | \(.size_in_bytes) bytes | created \(.created_at)"' \
            | awk 'NR<=100'
